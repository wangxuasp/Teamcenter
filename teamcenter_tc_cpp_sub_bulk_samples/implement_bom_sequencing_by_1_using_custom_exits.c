/*HEAD IMPLEMENT_BOM_SEQUENCING_BY_1_USING_CUSTOM_EXITS CCC UFUN */
/*
    %TC_ROOT%\sample\compile -DIPLIB=none gtac_ask_new_seqno.c
    %TC_ROOT%\sample\link_custom_exits GTAC

    cp GTAC.dll %TC_BIN%

    %TC_BIN%\preferences_manager -u=infodba -p=infodba -mode=import -action=merge -preference=TC_customization_libraries -scope=SITE -values=GTAC

*/

#include <ict/ict_userservice.h>
#include <user_exits/user_exits.h>
#include <tccore/custom.h>
#include <itk/mem.h>
#include <tc/tc.h>
#include <ps/ps.h>
#include <tc/emh.h>
#include <stdarg.h>

static void ECHO(char *format, ...)
{
    char msg[1000];
    va_list args;
    va_start(args, format);
    vsprintf(msg, format, args);
    va_end(args);
    printf(msg);
    TC_write_syslog(msg);
}

#define IFERR_ABORT(X)  (report_error( __FILE__, __LINE__, #X, X, TRUE))
#define IFERR_REPORT(X) (report_error( __FILE__, __LINE__, #X, X, FALSE))

static int report_error(char *file, int line, char *call, int status,
    logical exit_on_error)
{
    if (status != ITK_ok)
    {
        int
            n_errors = 0,
            *severities = NULL,
            *statuses = NULL;
        char
            **messages;

        EMH_ask_errors(&n_errors, &severities, &statuses, &messages);
        if (n_errors > 0)
        {
            ECHO("\n%s\n", messages[n_errors-1]);
            EMH_clear_errors();
        }
        else
        {
            char *error_message_string;
            EMH_get_error_string (NULLTAG, status, &error_message_string);
            ECHO("\n%s\n", error_message_string);
        }

        ECHO("error %d at line %d in %s\n", status, line, file);
        ECHO("%s\n", call);

        if (exit_on_error)
        {
            ECHO("Exiting program!\n");
            exit (status);
        }
    }

    return status;
}

/* Initial sequence number */
#define DEFAULT_SEQUENCE_NO "1"

extern int GTAC_ask_new_seqno(int *decision, va_list args)
{
    /***********  va_list for USER_ask_new_seqno ***********/
    tag_t  parent_bom_rev = va_arg(args, tag_t);
    tag_t  item = va_arg(args, tag_t);
    char  **seqno = va_arg(args, char **);
    /***********************************************************/

    ECHO("GTAC_ask_new_seqno\n");
    *decision = ONLY_CURRENT_CUSTOMIZATION;

    if (parent_bom_rev == null_tag)
    {
       char *my_string = (char *)MEM_alloc(strlen(DEFAULT_SEQUENCE_NO) + 1);
       strcpy(my_string, DEFAULT_SEQUENCE_NO);
       *seqno = my_string;
    }
    else
    {
        char *sequence_no = 0;

    /*  BEGIN Add for sequencing by 1 instead of 10 */
        char *my_string = NULL;
        char *occurrence_seq = NULL;
        char match[6] = "False";
        int n_occurrences = 0;
        int i = 0;
        tag_t *t_occurrences;
    /*  END Add for sequencing by 1 instead of 10 */

        int ifail = PS_bvr_ask_default_next_seq_no(parent_bom_rev, item,
            &sequence_no);
        if ( ifail != ITK_ok )
        {
           if (ifail != PS_no_seq_no)
           {
                return ITK_ok;
           }
           else if( ifail != ITK_ok )
           {
               EMH_clear_last_error(PS_no_seq_no);
           }
        }
   /*  BEGIN Add for sequencing by 1 instead of 10 */

/*  Addition so sequence numbers are generated by one and not ten.  Changed
    the DEFAULT_SEQUENCE_NO to "1".  Getting the list of occurrences in
    the BVR and looping through them to check for a match.  If match is
    found keep existing find number.  if match is not found subtract 9
    from the sequence number.

    was:
    *seqno = sequence_no;
*/

        PS_list_occurrences_of_bvr(parent_bom_rev, &n_occurrences,
            &t_occurrences);

        for( i = 0; i < n_occurrences; i ++ ) //looping through occurrences
        {
            PS_ask_seq_no(parent_bom_rev, t_occurrences[i], &occurrence_seq);

            if ( tc_strcasecmp(occurrence_seq, sequence_no) == 0)
            {
                ECHO("Found Seq Match\n");
                strcpy(match, "True");
                *seqno = sequence_no;
                break;
            }
            else
            {
                ECHO("No Seq Match\n");
                strcpy(match, "False");
            }
        }

        if ( tc_strcasecmp(match, "False") == 0)
        {
            my_string = (char *)MEM_alloc ( strlen ( sequence_no ) + 1);
            sprintf(my_string, "%d", atoi(sequence_no) - 9);
            *seqno = my_string;
        }
    /*  END Add for sequencing by 1 instead of 10 */

    }
    return ITK_ok;
}

/* This function name must be <library_name>_register_callbacks */
extern DLLAPI int GTAC_register_callbacks()
{
    ECHO("GTAC_register_callbacks\n");

    IFERR_REPORT(CUSTOM_register_exit( "GTAC", "USER_ask_new_seqno",
        (CUSTOM_EXIT_ftn_t) GTAC_ask_new_seqno));
    return ITK_ok;
}
